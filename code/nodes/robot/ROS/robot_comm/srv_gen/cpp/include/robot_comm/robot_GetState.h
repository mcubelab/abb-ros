/* Auto-generated by genmsg_cpp for file /home/mcube/hands_MLab/code/nodes/robot/ROS/robot_comm/srv/robot_GetState.srv */
#ifndef ROBOT_COMM_SERVICE_ROBOT_GETSTATE_H
#define ROBOT_COMM_SERVICE_ROBOT_GETSTATE_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "ros/service_traits.h"




namespace robot_comm
{
template <class ContainerAllocator>
struct robot_GetStateRequest_ {
  typedef robot_GetStateRequest_<ContainerAllocator> Type;

  robot_GetStateRequest_()
  {
  }

  robot_GetStateRequest_(const ContainerAllocator& _alloc)
  {
  }


  typedef boost::shared_ptr< ::robot_comm::robot_GetStateRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::robot_comm::robot_GetStateRequest_<ContainerAllocator>  const> ConstPtr;
}; // struct robot_GetStateRequest
typedef  ::robot_comm::robot_GetStateRequest_<std::allocator<void> > robot_GetStateRequest;

typedef boost::shared_ptr< ::robot_comm::robot_GetStateRequest> robot_GetStateRequestPtr;
typedef boost::shared_ptr< ::robot_comm::robot_GetStateRequest const> robot_GetStateRequestConstPtr;



template <class ContainerAllocator>
struct robot_GetStateResponse_ {
  typedef robot_GetStateResponse_<ContainerAllocator> Type;

  robot_GetStateResponse_()
  : tcp(0.0)
  , ori(0.0)
  , zone(0)
  , vacuum(0)
  , workx(0.0)
  , worky(0.0)
  , workz(0.0)
  , workq0(0.0)
  , workqx(0.0)
  , workqy(0.0)
  , workqz(0.0)
  , toolx(0.0)
  , tooly(0.0)
  , toolz(0.0)
  , toolq0(0.0)
  , toolqx(0.0)
  , toolqy(0.0)
  , toolqz(0.0)
  , ret(0)
  , msg()
  {
  }

  robot_GetStateResponse_(const ContainerAllocator& _alloc)
  : tcp(0.0)
  , ori(0.0)
  , zone(0)
  , vacuum(0)
  , workx(0.0)
  , worky(0.0)
  , workz(0.0)
  , workq0(0.0)
  , workqx(0.0)
  , workqy(0.0)
  , workqz(0.0)
  , toolx(0.0)
  , tooly(0.0)
  , toolz(0.0)
  , toolq0(0.0)
  , toolqx(0.0)
  , toolqy(0.0)
  , toolqz(0.0)
  , ret(0)
  , msg(_alloc)
  {
  }

  typedef double _tcp_type;
  double tcp;

  typedef double _ori_type;
  double ori;

  typedef int64_t _zone_type;
  int64_t zone;

  typedef int64_t _vacuum_type;
  int64_t vacuum;

  typedef double _workx_type;
  double workx;

  typedef double _worky_type;
  double worky;

  typedef double _workz_type;
  double workz;

  typedef double _workq0_type;
  double workq0;

  typedef double _workqx_type;
  double workqx;

  typedef double _workqy_type;
  double workqy;

  typedef double _workqz_type;
  double workqz;

  typedef double _toolx_type;
  double toolx;

  typedef double _tooly_type;
  double tooly;

  typedef double _toolz_type;
  double toolz;

  typedef double _toolq0_type;
  double toolq0;

  typedef double _toolqx_type;
  double toolqx;

  typedef double _toolqy_type;
  double toolqy;

  typedef double _toolqz_type;
  double toolqz;

  typedef int64_t _ret_type;
  int64_t ret;

  typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _msg_type;
  std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  msg;


  typedef boost::shared_ptr< ::robot_comm::robot_GetStateResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::robot_comm::robot_GetStateResponse_<ContainerAllocator>  const> ConstPtr;
}; // struct robot_GetStateResponse
typedef  ::robot_comm::robot_GetStateResponse_<std::allocator<void> > robot_GetStateResponse;

typedef boost::shared_ptr< ::robot_comm::robot_GetStateResponse> robot_GetStateResponsePtr;
typedef boost::shared_ptr< ::robot_comm::robot_GetStateResponse const> robot_GetStateResponseConstPtr;


struct robot_GetState
{

typedef robot_GetStateRequest Request;
typedef robot_GetStateResponse Response;
Request request;
Response response;

typedef Request RequestType;
typedef Response ResponseType;
}; // struct robot_GetState
} // namespace robot_comm

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::robot_comm::robot_GetStateRequest_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::robot_comm::robot_GetStateRequest_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::robot_comm::robot_GetStateRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "d41d8cd98f00b204e9800998ecf8427e";
  }

  static const char* value(const  ::robot_comm::robot_GetStateRequest_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xd41d8cd98f00b204ULL;
  static const uint64_t static_value2 = 0xe9800998ecf8427eULL;
};

template<class ContainerAllocator>
struct DataType< ::robot_comm::robot_GetStateRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "robot_comm/robot_GetStateRequest";
  }

  static const char* value(const  ::robot_comm::robot_GetStateRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::robot_comm::robot_GetStateRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "\n\
\n\
\n\
";
  }

  static const char* value(const  ::robot_comm::robot_GetStateRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::robot_comm::robot_GetStateRequest_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros


namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::robot_comm::robot_GetStateResponse_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::robot_comm::robot_GetStateResponse_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::robot_comm::robot_GetStateResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "05aedda03af788fdd5136bc85aecf863";
  }

  static const char* value(const  ::robot_comm::robot_GetStateResponse_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x05aedda03af788fdULL;
  static const uint64_t static_value2 = 0xd5136bc85aecf863ULL;
};

template<class ContainerAllocator>
struct DataType< ::robot_comm::robot_GetStateResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "robot_comm/robot_GetStateResponse";
  }

  static const char* value(const  ::robot_comm::robot_GetStateResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::robot_comm::robot_GetStateResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "float64 tcp\n\
float64 ori\n\
int64 zone\n\
int64 vacuum\n\
float64 workx\n\
float64 worky\n\
float64 workz\n\
float64 workq0\n\
float64 workqx\n\
float64 workqy\n\
float64 workqz\n\
float64 toolx\n\
float64 tooly\n\
float64 toolz\n\
float64 toolq0\n\
float64 toolqx\n\
float64 toolqy\n\
float64 toolqz\n\
int64 ret\n\
string msg\n\
\n\
\n\
";
  }

  static const char* value(const  ::robot_comm::robot_GetStateResponse_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::robot_comm::robot_GetStateRequest_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct robot_GetStateRequest_
} // namespace serialization
} // namespace ros


namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::robot_comm::robot_GetStateResponse_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.tcp);
    stream.next(m.ori);
    stream.next(m.zone);
    stream.next(m.vacuum);
    stream.next(m.workx);
    stream.next(m.worky);
    stream.next(m.workz);
    stream.next(m.workq0);
    stream.next(m.workqx);
    stream.next(m.workqy);
    stream.next(m.workqz);
    stream.next(m.toolx);
    stream.next(m.tooly);
    stream.next(m.toolz);
    stream.next(m.toolq0);
    stream.next(m.toolqx);
    stream.next(m.toolqy);
    stream.next(m.toolqz);
    stream.next(m.ret);
    stream.next(m.msg);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct robot_GetStateResponse_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace service_traits
{
template<>
struct MD5Sum<robot_comm::robot_GetState> {
  static const char* value() 
  {
    return "05aedda03af788fdd5136bc85aecf863";
  }

  static const char* value(const robot_comm::robot_GetState&) { return value(); } 
};

template<>
struct DataType<robot_comm::robot_GetState> {
  static const char* value() 
  {
    return "robot_comm/robot_GetState";
  }

  static const char* value(const robot_comm::robot_GetState&) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<robot_comm::robot_GetStateRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "05aedda03af788fdd5136bc85aecf863";
  }

  static const char* value(const robot_comm::robot_GetStateRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<robot_comm::robot_GetStateRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "robot_comm/robot_GetState";
  }

  static const char* value(const robot_comm::robot_GetStateRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<robot_comm::robot_GetStateResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "05aedda03af788fdd5136bc85aecf863";
  }

  static const char* value(const robot_comm::robot_GetStateResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<robot_comm::robot_GetStateResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "robot_comm/robot_GetState";
  }

  static const char* value(const robot_comm::robot_GetStateResponse_<ContainerAllocator> &) { return value(); } 
};

} // namespace service_traits
} // namespace ros

#endif // ROBOT_COMM_SERVICE_ROBOT_GETSTATE_H

