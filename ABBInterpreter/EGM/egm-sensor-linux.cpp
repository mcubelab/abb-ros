/////////////////////////////////////////////////////////////////////////
// Sample using Google protocol buffers C++
//
#include <iostream>
#include <fstream>
#include "PracticalSocket/PracticalSocket.h" // For UDPSocket and SocketException

#include "egm.pb.h" // generated by Google protoc.exe
#include <unistd.h>
static int portNumber = 6510;
static unsigned int sequenceNumber = 0;

using namespace std;
using namespace abb::egm;

uint32_t GetTickCount(void) 
{
  struct timespec now;
  if (clock_gettime(CLOCK_MONOTONIC, &now))
    return 0;
  return now.tv_sec * 1000 + now.tv_nsec / 1000000;
}


//////////////////////////////////////////////////////////////////////////
// Create a simple sensor message
void CreateSensorMessage(EgmSensor* pSensorMessage)
{
    EgmHeader* header = new EgmHeader();
    header->set_mtype(EgmHeader_MessageType_MSGTYPE_CORRECTION);
    header->set_seqno(sequenceNumber++);
    header->set_tm(GetTickCount());

    pSensorMessage->set_allocated_header(header);

    EgmCartesian *pc = new EgmCartesian();
    pc->set_x(305);
    pc->set_y(-0.33);
    pc->set_z(500);

    EgmQuaternion *pq = new EgmQuaternion();
    pq->set_u0(0.7071);
    pq->set_u1(-0.0);
    pq->set_u2(-0.7071);
    pq->set_u3(-0.0);

    EgmPose *pcartesian = new EgmPose();
    pcartesian->set_allocated_orient(pq);
    pcartesian->set_allocated_pos(pc);

    EgmPlanned *planned = new EgmPlanned();
    planned->set_allocated_cartesian(pcartesian);

    pSensorMessage->set_allocated_planned(planned);
}

//////////////////////////////////////////////////////////////////////////
// Display inbound robot message
void DisplayRobotMessage(EgmRobot *pRobotMessage)
{
    if (pRobotMessage->has_header() && pRobotMessage->header().has_seqno() && pRobotMessage->header().has_tm() && pRobotMessage->header().has_mtype())
    {
        printf("SeqNo=%d Tm=%u Type=%d\n", pRobotMessage->header().seqno(), pRobotMessage->header().tm(), pRobotMessage->header().mtype());
    }
    else
    {
        printf("No header\n");
    }
}

int main(int argc, char* argv[])
{
    UDPSocket* EGMsock;
    int n;
    //struct sockaddr_in serverAddr, clientAddr;
    int len;
    const int MAX_BUFFER = 1400;
    char buffer[MAX_BUFFER];
    int recvMsgSize;
    string sourceAddress;             // Address of datagram source
    unsigned short sourcePort;        // Port of datagram source

    EGMsock = new UDPSocket(portNumber);
    /* Init winsock */
    // WSADATA wsaData;
    // if (WSAStartup(MAKEWORD(2,2), &wsaData) != 0)
    // {
        // fprintf(stderr, "Could not open Windows connection.\n");
        // exit(0);
    // }
    

    // create socket to listen on
    // sockfd = ::socket(AF_INET,SOCK_DGRAM,0);
// 
    // memset(&serverAddr, sizeof(serverAddr), 0);
    // serverAddr.sin_family = AF_INET;
    // serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    // serverAddr.sin_port = htons(portNumber);
// 
    //listen on all interfaces
    // bind(sockfd, (struct sockaddr *)&serverAddr, sizeof(serverAddr));

    string messageBuffer;
    //for (int messages = 0; messages < 100000; messages++)
    while(1)
    {
      try{
        // receive and display message from robot
        //len = sizeof(clientAddr);
        
        recvMsgSize = EGMsock->recvFrom(buffer, MAX_BUFFER-1, sourceAddress, sourcePort);
    
        //n = recvfrom(sockfd, protoMessage, 1400, 0, (struct sockaddr *)&clientAddr, &len);
        if (recvMsgSize < 0)
        {
            printf("Error receive message\n");
            continue;
        }
        else {
            printf("Received %d\n", recvMsgSize);
        }

        // deserialize inbound message
        EgmRobot *pRobotMessage = new EgmRobot();
        pRobotMessage->ParseFromArray(buffer, n);
        DisplayRobotMessage(pRobotMessage);
        delete pRobotMessage;

        // create and send a sensor message
        EgmSensor *pSensorMessage = new EgmSensor();
        CreateSensorMessage(pSensorMessage);
        pSensorMessage->SerializeToString(&messageBuffer);

        // send a message to the robot
        //n = sendto(sockfd, messageBuffer.c_str(), messageBuffer.length(), 0, (struct sockaddr *)&clientAddr, sizeof(clientAddr));
        //n = sendto(sockfd, messageBuffer.c_str(), messageBuffer.length(), 0, (struct sockaddr *)&clientAddr, sizeof(clientAddr));
        EGMsock->sendTo(messageBuffer.c_str(), messageBuffer.length(), sourceAddress, sourcePort);
        // if (n < 0)
        // {
            // printf("Error send message\n");
        // }
        // else{
        printf("Sent %lu\n", messageBuffer.length());
        //cout << "sent" <<
        // }
        delete pSensorMessage;
        usleep(1000);
      } catch (SocketException &e) {
        // no data
        //cerr << e.what() << endl;
      }
    }
    return 0;
}

